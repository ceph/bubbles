import ceph_module
import logging
from rados import Rados
import sqlite3
from enum import IntEnum
from typing import (
    Any,
    Callable,
    Dict,
    List,
    Mapping,
    NamedTuple,
    Optional,
    Sequence,
    Tuple,
    Union,
)

ERROR_MSG_EMPTY_INPUT_FILE: str
ERROR_MSG_NO_INPUT_FILE: str
PG_STATES: Any
NFS_POOL_NAME: str

class CommandResult:
    ev: Any
    outs: str
    outb: str
    r: int
    tag: Any
    def __init__(self, tag: Optional[str] = ...) -> None: ...
    def complete(self, r: int, outb: str, outs: str) -> None: ...
    def wait(self) -> Tuple[int, str, str]: ...

class HandleCommandResult(NamedTuple):
    retval: int
    stdout: str
    stderr: str

class MonCommandFailed(RuntimeError): ...
class MgrDBNotReady(RuntimeError): ...

class OSDMap(ceph_module.BasePyOSDMap):
    def get_epoch(self) -> int: ...
    def get_crush_version(self) -> int: ...
    def dump(self) -> Dict[str, Any]: ...
    def get_pools(self) -> Dict[int, Dict[str, Any]]: ...
    def get_pools_by_name(self) -> Dict[str, Dict[str, Any]]: ...
    def new_incremental(self) -> OSDMapIncremental: ...
    def apply_incremental(self, inc: OSDMapIncremental) -> OSDMap: ...
    def get_crush(self) -> CRUSHMap: ...
    def get_pools_by_take(self, take: int) -> List[int]: ...
    def calc_pg_upmaps(
        self,
        inc: OSDMapIncremental,
        max_deviation: int,
        max_iterations: int = ...,
        pools: Optional[List[str]] = ...,
    ) -> int: ...
    def map_pool_pgs_up(self, poolid: int) -> List[int]: ...
    def pg_to_up_acting_osds(self, pool_id: int, ps: int) -> Dict[str, Any]: ...
    def pool_raw_used_rate(self, pool_id: int) -> float: ...
    @classmethod
    def build_simple(
        cls, epoch: int = ..., uuid: Optional[str] = ..., num_osd: int = ...
    ) -> ceph_module.BasePyOSDMap: ...
    def get_ec_profile(self, name: str) -> Optional[List[Dict[str, str]]]: ...
    def get_require_osd_release(self) -> str: ...

class OSDMapIncremental(ceph_module.BasePyOSDMapIncremental):
    def get_epoch(self) -> int: ...
    def dump(self) -> Dict[str, Any]: ...
    def set_osd_reweights(self, weightmap: Dict[int, float]) -> None: ...
    def set_crush_compat_weight_set_weights(
        self, weightmap: Dict[str, float]
    ) -> None: ...

class CRUSHMap(ceph_module.BasePyCRUSH):
    ITEM_NONE: int
    DEFAULT_CHOOSE_ARGS: str
    def dump(self) -> Dict[str, Any]: ...
    def get_item_weight(self, item: int) -> Optional[int]: ...
    def get_item_name(self, item: int) -> Optional[str]: ...
    def find_takes(self) -> List[int]: ...
    def find_roots(self) -> List[int]: ...
    def get_take_weight_osd_map(self, root: int) -> Dict[int, float]: ...
    @staticmethod
    def have_default_choose_args(dump: Dict[str, Any]) -> bool: ...
    @staticmethod
    def get_default_choose_args(
        dump: Dict[str, Any]
    ) -> List[Dict[str, Any]]: ...
    def get_rule(self, rule_name: str) -> Optional[Dict[str, Any]]: ...
    def get_rule_by_id(self, rule_id: int) -> Optional[Dict[str, Any]]: ...
    def get_rule_root(self, rule_name: str) -> Optional[int]: ...
    def get_osds_under(self, root_id: int) -> List[int]: ...
    def device_class_counts(self) -> Dict[str, int]: ...

HandlerFuncType = Callable[..., Tuple[int, str, str]]

class CLICommand:
    COMMANDS: Dict[str, CLICommand]
    prefix: Any
    perm: Any
    poll: Any
    func: Any
    arg_spec: Any
    first_default: int
    def __init__(
        self, prefix: str, perm: str = ..., poll: bool = ...
    ) -> None: ...
    KNOWN_ARGS: Any
    @staticmethod
    def load_func_metadata(
        f: HandlerFuncType,
    ) -> Tuple[str, Dict[str, Any], int, str]: ...
    def store_func_metadata(self, f: HandlerFuncType) -> None: ...
    def __call__(self, func: HandlerFuncType) -> HandlerFuncType: ...
    def call(
        self, mgr: Any, cmd_dict: Dict[str, Any], inbuf: Optional[str] = ...
    ) -> HandleCommandResult: ...
    def dump_cmd(self) -> Dict[str, Union[str, bool]]: ...
    @classmethod
    def dump_cmd_list(cls) -> List[Dict[str, Union[str, bool]]]: ...

def CLIReadCommand(prefix: str, poll: bool = ...) -> CLICommand: ...
def CLIWriteCommand(prefix: str, poll: bool = ...) -> CLICommand: ...
def CLICheckNonemptyFileInput(
    desc: str,
) -> Callable[[HandlerFuncType], HandlerFuncType]: ...
def CLIRequiresDB(func: HandlerFuncType) -> HandlerFuncType: ...

OptionTypeLabel: Any
OptionValue = Optional[Union[bool, int, float, str]]

class Option(Dict[str, Any]):
    def __init__(
        self,
        name: str,
        default: OptionValue = ...,
        type: OptionTypeLabel = ...,
        desc: Optional[str] = ...,
        long_desc: Optional[str] = ...,
        min: OptionValue = ...,
        max: OptionValue = ...,
        enum_allowed: Optional[List[str]] = ...,
        tags: Optional[List[str]] = ...,
        see_also: Optional[List[str]] = ...,
        runtime: bool = ...,
    ) -> None: ...

class Command(dict):  # type: ignore
    prefix: Any
    handler: Any
    def __init__(
        self,
        prefix: str,
        handler: HandlerFuncType,
        perm: str = ...,
        poll: bool = ...,
    ) -> None: ...
    @staticmethod
    def returns_command_result(
        instance: Any, f: HandlerFuncType
    ) -> Callable[..., HandleCommandResult]: ...
    def register(self, instance: bool = ...) -> HandlerFuncType: ...

class CPlusPlusHandler(logging.Handler):
    def __init__(self, module_inst: Any) -> None: ...
    def emit(self, record: logging.LogRecord) -> None: ...

class ClusterLogHandler(logging.Handler):
    def __init__(self, module_inst: Any) -> None: ...
    def emit(self, record: logging.LogRecord) -> None: ...

class FileHandler(logging.FileHandler):
    path: Any
    def __init__(self, module_inst: Any) -> None: ...

class MgrModuleLoggingMixin:
    def getLogger(self, name: Optional[str] = ...) -> logging.Logger: ...

class MgrStandbyModule(ceph_module.BaseMgrStandbyModule, MgrModuleLoggingMixin):
    MODULE_OPTIONS: List[Option]
    MODULE_OPTION_DEFAULTS: Dict[str, Any]
    module_name: Any
    def __init__(self, module_name: str, capsule: Any) -> None: ...
    def __del__(self) -> None: ...
    @property
    def log(self) -> logging.Logger: ...
    def serve(self) -> None: ...
    def get_mgr_id(self) -> str: ...
    def get_module_option(
        self, key: str, default: OptionValue = ...
    ) -> OptionValue: ...
    def get_ceph_option(self, key: str) -> OptionValue: ...
    def get_store(self, key: str) -> Optional[str]: ...
    def get_localized_store(
        self, key: str, default: Optional[str] = ...
    ) -> Optional[str]: ...
    def get_active_uri(self) -> str: ...
    def get(self, data_name: str) -> Any: ...
    def get_mgr_ip(self) -> str: ...
    def get_localized_module_option(
        self, key: str, default: OptionValue = ...
    ) -> OptionValue: ...

HealthChecksT = Mapping[str, Mapping[str, Union[int, str, Sequence[str]]]]
ServiceInfoT = Dict[str, str]
ServerInfoT = Dict[str, Union[str, List[ServiceInfoT]]]
PerfCounterT = Dict[str, Any]

class MgrModule(ceph_module.BaseMgrModule, MgrModuleLoggingMixin):
    MGR_POOL_NAME: str
    COMMANDS: List[Any]
    MODULE_OPTIONS: List[Option]
    MODULE_OPTION_DEFAULTS: Dict[str, Any]
    SCHEMA: Optional[str]
    SCHEMA_VERSIONED: Optional[List[str]]
    PRIO_CRITICAL: int
    PRIO_INTERESTING: int
    PRIO_USEFUL: int
    PRIO_UNINTERESTING: int
    PRIO_DEBUGONLY: int
    PERFCOUNTER_TIME: int
    PERFCOUNTER_U64: int
    PERFCOUNTER_LONGRUNAVG: int
    PERFCOUNTER_COUNTER: int
    PERFCOUNTER_HISTOGRAM: int
    PERFCOUNTER_TYPE_MASK: int
    BYTES: int
    NONE: int
    class ClusterLogPrio(IntEnum):
        DEBUG: int
        INFO: int
        SEC: int
        WARN: int
        ERROR: int
    module_name: Any
    def __init__(
        self, module_name: str, py_modules_ptr: object, this_ptr: object
    ) -> None: ...
    def __del__(self) -> None: ...
    @property
    def log(self) -> logging.Logger: ...
    def cluster_log(
        self, channel: str, priority: ClusterLogPrio, message: str
    ) -> None: ...
    @property
    def version(self) -> str: ...
    def pool_exists(self, name: str) -> bool: ...
    def have_enough_osds(self) -> bool: ...
    def rename_pool(self, srcpool: str, destpool: str) -> None: ...
    def create_pool(self, pool: str) -> None: ...
    def appify_pool(self, pool: str, app: str) -> None: ...
    def create_mgr_pool(self) -> None: ...
    def create_skeleton_schema(self, db: sqlite3.Connection) -> None: ...
    def update_schema_version(
        self, db: sqlite3.Connection, version: int
    ) -> None: ...
    def set_kv(self, key: str, value: Any) -> None: ...
    def get_kv(self, key: str) -> Any: ...
    def maybe_upgrade(self, db: sqlite3.Connection, version: int) -> None: ...
    def load_schema(self, db: sqlite3.Connection) -> None: ...
    def configure_db(self, db: sqlite3.Connection) -> None: ...
    def open_db(self) -> Optional[sqlite3.Connection]: ...
    def db_ready(self) -> bool: ...
    @property
    def db(self) -> sqlite3.Connection: ...
    @property
    def release_name(self) -> str: ...
    def lookup_release_name(self, major: int) -> str: ...
    def get_context(self) -> object: ...
    def notify(self, notify_type: str, notify_id: str) -> None: ...
    def config_notify(self) -> None: ...
    def serve(self) -> None: ...
    def shutdown(self) -> None: ...
    def get(self, data_name: str) -> Any: ...
    @staticmethod
    def to_pretty_iec(n: int) -> str: ...
    @staticmethod
    def get_pretty_row(elems: Sequence[str], width: int) -> str: ...
    def get_pretty_header(self, elems: Sequence[str], width: int) -> str: ...
    def get_server(self, hostname: str) -> ServerInfoT: ...
    def get_perf_schema(
        self, svc_type: str, svc_name: str
    ) -> Dict[str, Dict[str, Dict[str, Union[str, int]]]]: ...
    def get_counter(
        self, svc_type: str, svc_name: str, path: str
    ) -> Dict[str, List[Tuple[float, int]]]: ...
    def get_latest_counter(
        self, svc_type: str, svc_name: str, path: str
    ) -> Dict[str, Union[Tuple[float, int], Tuple[float, int, int]]]: ...
    def list_servers(self) -> List[ServerInfoT]: ...
    def get_metadata(
        self,
        svc_type: str,
        svc_id: str,
        default: Optional[Dict[str, str]] = ...,
    ) -> Optional[Dict[str, str]]: ...
    def get_daemon_status(
        self, svc_type: str, svc_id: str
    ) -> Dict[str, str]: ...
    def check_mon_command(
        self, cmd_dict: Dict[str, Any], inbuf: Optional[str] = ...
    ) -> HandleCommandResult: ...
    def mon_command(
        self, cmd_dict: Dict[str, Any], inbuf: Optional[str] = ...
    ) -> Tuple[int, str, str]: ...
    def send_command(
        self,
        result: CommandResult,
        svc_type: str,
        svc_id: str,
        command: str,
        tag: str,
        inbuf: Optional[str] = ...,
    ) -> None: ...
    def set_health_checks(self, checks: HealthChecksT) -> None: ...
    def handle_command(
        self, inbuf: str, cmd: Dict[str, Any]
    ) -> Union[HandleCommandResult, Tuple[int, str, str]]: ...
    def get_mgr_id(self) -> str: ...
    def get_ceph_conf_path(self) -> str: ...
    def get_mgr_ip(self) -> str: ...
    def get_ceph_option(self, key: str) -> OptionValue: ...
    def get_foreign_ceph_option(self, entity: str, key: str) -> OptionValue: ...
    def get_module_option(
        self, key: str, default: OptionValue = ...
    ) -> OptionValue: ...
    def get_module_option_ex(
        self, module: str, key: str, default: OptionValue = ...
    ) -> OptionValue: ...
    def get_store_prefix(self, key_prefix: str) -> Dict[str, str]: ...
    def get_localized_module_option(
        self, key: str, default: OptionValue = ...
    ) -> OptionValue: ...
    def set_module_option(self, key: str, val: Any) -> None: ...
    def set_module_option_ex(
        self, module: str, key: str, val: OptionValue
    ) -> None: ...
    def set_localized_module_option(
        self, key: str, val: Optional[str]
    ) -> None: ...
    def set_store(self, key: str, val: Optional[str]) -> None: ...
    def get_store(
        self, key: str, default: Optional[str] = ...
    ) -> Optional[str]: ...
    def get_localized_store(
        self, key: str, default: Optional[str] = ...
    ) -> Optional[str]: ...
    def set_localized_store(self, key: str, val: Optional[str]) -> None: ...
    def self_test(self) -> Optional[str]: ...
    def get_osdmap(self) -> OSDMap: ...
    def get_latest(
        self, daemon_type: str, daemon_name: str, counter: str
    ) -> int: ...
    def get_latest_avg(
        self, daemon_type: str, daemon_name: str, counter: str
    ) -> Tuple[int, int]: ...
    def get_all_perf_counters(
        self, prio_limit: int = ..., services: Sequence[str] = ...
    ) -> Dict[str, Dict[str, Any]]: ...
    def set_uri(self, uri: str) -> None: ...
    def set_device_wear_level(self, devid: str, wear_level: float) -> None: ...
    def have_mon_connection(self) -> bool: ...
    def update_progress_event(
        self, evid: str, desc: str, progress: float, add_to_ceph_s: bool
    ) -> None: ...
    def complete_progress_event(self, evid: str) -> None: ...
    def clear_all_progress_events(self) -> None: ...
    @property
    def rados(self) -> Rados: ...
    @staticmethod
    def can_run() -> Tuple[bool, str]: ...
    def remote(
        self, module_name: str, method_name: str, *args: Any, **kwargs: Any
    ) -> Any: ...
    def add_osd_perf_query(self, query: Dict[str, Any]) -> Optional[int]: ...
    def remove_osd_perf_query(self, query_id: int) -> None: ...
    def get_osd_perf_counters(
        self, query_id: int
    ) -> Optional[Dict[str, List[PerfCounterT]]]: ...
    def add_mds_perf_query(self, query: Dict[str, Any]) -> Optional[int]: ...
    def remove_mds_perf_query(self, query_id: int) -> None: ...
    def get_mds_perf_counters(
        self, query_id: int
    ) -> Optional[Dict[str, List[PerfCounterT]]]: ...
    def is_authorized(self, arguments: Dict[str, str]) -> bool: ...
